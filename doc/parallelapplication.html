<!-- Copyright (c) 2001, Stanford University
     All rights reserved.

	 See the file LICENSE.txt for information on redistributing this software.  -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>New Page 1</title>
<base target="_self">
<link rel="stylesheet" type="text/css" href="chromium.css">
</head>

<body bgcolor="#FFFFFF">

<h1 class="PageHeading">Writing a Parallel Application</h1>

<table border="1" width="100%">
	<tr>
		<td align="center">
            <p align="center"><img border="0" src="rings.jpg"></p>
		</td>
	</tr>
	<tr>
		<td align="center">
            Each ring is submitted/rendered by a separate client in a
            cluster-parallel program.
		</td>
	</tr>
</table>
<p>The Chromium server can serialize multiple incoming streams from a
distributed OpenGL application.&nbsp; Here we will build a trivial parallel
application using Chromium.&nbsp; The application that we will be considering is
called psubmit, and can be found in the directory <code>cr/progs/psumit</code>.</p>
<h2 class="PageSubHeading">The Basic Idea</h2>
<p>Writing a parallel OpenGL application is pretty simple.&nbsp; You have a
bunch of processes, each one of which is responsible for a portion of the model
to be rendered.&nbsp; Each process renders its portion pretty much as if it
were the only process in the world.&nbsp;
The partial renderings may either be composited together according to Z or
alpha (sort-last) or tiled together (sort-first).
However, <i>ordering</i> requirements add some complexity to the process.</p>

<p>OpenGL provides <i>ordered semantics</i>.&nbsp; That means that if function A
is called before function B, the resulting image should look as if A happened
before B.&nbsp; With parallel programs, it's no longer clear which function is
getting called first.&nbsp; Therefore, if you aren't using the depth test (for
example), and you draw two overlapping triangles in parallel, you don't know
which one will appear on top.&nbsp; To get around this problem, Chromium
implements the parallel API proposed by <a href="http://graphics.stanford.edu/papers/parallel_api/" target="new_window">Igehy,
Stoll and Hanrahan in SIGGRAPH '98</a>.&nbsp; This API extends OpenGL to have
barriers and semaphores, which are sufficient to express almost all ordering
constraints that come up in graphics.</p>
<p>Let's take a look at the <code>main</code> function of <code>psubmit.c</code>
in <code>cr/progs/psubmit</code>.&nbsp; The first thing this function does is
determines how many of its peers exist, and which instance number (starting from
0) this particular <code>main</code> is running in.&nbsp; In <code>psubmit</code>,
this is done with command line arguments, although more complex programs will
probably need to do some sort of application-level communication or
synchronization and would get this information from, say, MPI.</p>
<p>Once the rank and size of the program are determined, the following two lines
appear:</p>

<table width="100%" height="35"><tr><td class="GrayCodeListing" height="31">		context = crCreateContextCR(NULL, CR_RGB_BIT | CR_DEPTH_BIT | CR_DOUBLE_BIT);<br>
	crMakeCurrentCR(NULL, 0, context);</td></tr></table>

<p>crCreateContextCR and crMakeCurrentCR are actually function pointers
initialized via crGetProcAddress.
The typedefs for these functions are in the header file
&quot;<code>cr_applications.h</code>&quot;.
They provide a mechanism to use Chromium without using GLX or WGL and
having to create applications windows, etc.
This is particularly useful for parallel applications, since it doesn't
really make sense to have a bunch of blank faked-out windows popping up
all over the cluster.&nbsp; This also means that the client nodes in the
cluster do not have to have a graphical environment running just to house
a blank faked-out window.</p>

<p>The <code>NULL</code> parameters are pointers which aren't used at
this time (they'll be used to specify the X display in the future).
The 0 parameter to <code>crMakeCurrentCR</code> is the window ID.
Zero indicates that the default window should be used.</p>

<p>The next thing that the application does is create a GL barrier:</p>

<table width="100%"><tr><td class="GrayCodeListing">		glBarrierCreate( MASTER_BARRIER, size );</td></tr></table>

<p>Notice that every node in the cluster will create this barrier.&nbsp; This is
perfectly legal, as long as the &quot;size&quot; parameter matches up.&nbsp; <code>MASTER_BARRIER</code>
is just an integer that &quot;names&quot; this barrier, much like an OpenGL
display list or texture object (except that the namespace is shared between
clients by default).</p>

<p>After some GL initialization code comes the main drawing loop.&nbsp;
This application follows the basic
format of all simple parallel OpenGL applications:</p>

<table width="100%"><tr><td class="GrayCodeListing">		for (;;)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (clearAndSwap) glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );<br>
      &nbsp;&nbsp;&nbsp; glBarrierExec( MASTER_BARRIER );<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Drawing code here<br>
      <br>
      &nbsp;&nbsp;&nbsp; glBarrierExec( MASTER_BARRIER );<br>
      &nbsp;&nbsp;&nbsp; if (clearAndSwap) crSwapBuffers();<br>
      }</td></tr></table>

<p>A few things to note about this drawing method:</p>
<ul>
  <li>In a sort-last configuration <code>clearAndSwap</code> be true
    for all processes.
  <li>In a sort-first configuration <code>clearAndSwap</code> be true
    only for the first (0th) process.
  <li><code>glBarrierExec</code> (also declared in <code>cr_applications.h</code>)
    is the call to enter a barrier.</li>
  <li>The barrier following the clear ensures that the clear has happened before
    <i>anyone</i> starts drawing</li>
  <li>The barrier preceding the swap ensures that <i>everyone</i> is finished
    drawing before the buffers are swapped</li>
  <li>Barriers (and semaphores) do <i>not</i> block the application.&nbsp; They
    simply indicate ordering constraints to be obeyed by the server when
    switching contexts.&nbsp; Therefore, the clients do not have to stall, and
    can get ahead of the servers.</li>
</ul>

<p>
To run the psubmit demo you'll need to issue the following commands, probably
from four separate shell windows:
</p>
<ul>
<li><code>cd mothership/configs ; python psubmit.conf</code>
<li><code>crserver</code>
<li><code>crappfaker</code>
<li><code>crappfaker</code>
</ul>

</body>

</html>
