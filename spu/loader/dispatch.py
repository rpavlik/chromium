# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

import sys,os;
import cPickle;
import string;
import re;

parsed_file = open( "../../glapi_parser/gl_header.parsed", "rb" )
gl_mapping = cPickle.load( parsed_file )

sys.path.append( "../../opengl_stub" )

import stub_common;

stub_common.CopyrightC()

print """

/* DO NOT EDIT - THIS FILE AUTOMATICALLY GENERATED BY dispatch.py SCRIPT */

#include "cr_spu.h"
#include "cr_string.h"
#include "cr_error.h"


static SPUGenericFunction __findFunc( char *name, SPU *spu )
{
	SPUNamedFunctionTable *temp;

	if (spu == NULL)
		return NULL;

	for (temp = spu->function_table->table ; temp->name != NULL ; temp++)
	{
		if (!crStrcmp( name, temp->name ) )
		{
			return temp->fn;
		}
	}
	return __findFunc( name, spu->superSPU );
}


/*
 * This function is not public outside the loader SPU.
 */
void __buildDispatch( SPU *spu )
{"""

keys = gl_mapping.keys()
keys.sort();

for func_name in keys:
	(return_type, names, types) = gl_mapping[func_name]
	print '\tspu->dispatch_table.%s = (%sFunc_t) __findFunc( "%s", spu );' % (func_name,func_name,func_name)
print '}'


print """

/*
 * Public function:
 * Search a SPU named function table for a specific function.  Return
 * a pointer to it or NULL if not found.
 */
SPUGenericFunction crSPUFindFunction( const SPUNamedFunctionTable *table, const char *fname )
{
	const SPUNamedFunctionTable *temp;

	for (temp = table ; temp->name != NULL ; temp++)
	{
		if (!crStrcmp( fname, temp->name ) )
		{
			return temp->fn;
		}
	}
	return NULL;
}


/*
 * Public function:
 * Initializes the pointers in an SPUDispatchTable by looking for functions
 * in an SPUNamedFunctionTable.
 * It doesn't know anything about SPUs and SPU inheritance.
 */
void crSPUInitDispatch( SPUDispatchTable *dispatch, const SPUNamedFunctionTable *table )
{"""

keys = gl_mapping.keys()
keys.sort();

for func_name in keys:
	(return_type, names, types) = gl_mapping[func_name]
	print '\tdispatch->%s = (%sFunc_t) crSPUFindFunction(table, "%s");' % (func_name, func_name, func_name)
print '}'



print """
/*
 * Generic no-op function
 */
static int NopFunction(void)
{
	crWarning("Calling generic no-op function in dispatch.c");
	return 0;
}


/*
 * Scan the given dispatch table for NULL pointers.  Hook in the generic
 * no-op function wherever we find a NULL pointer.
 */
void crSPUInitDispatchNops(SPUDispatchTable *table)
{
	const int numEntries = sizeof(*table) / sizeof(table->Accum);
	void **ptr = (void **) table;
	int i;
	for (i = 0; i < numEntries; i++) {
		if (ptr[i] == NULL) {
			/*printf("!!!!!!!Warning entry[%d] = NULL\n", i);*/
			ptr[i] = NopFunction;
		}
	}
}
"""
